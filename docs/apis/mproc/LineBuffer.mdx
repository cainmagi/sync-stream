---
id: LineBuffer
title: LineBuffer
sidebar_label: LineBuffer
slug: /apis/mproc/LineBuffer
description: The basic line-based buffer handle.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MDIIcon from '@mdi/react';
import { mdiFunctionVariant, mdiLockOutline } from '@mdi/js';
import { Icon, InlineIcon } from "@iconify/react";
import vsiSymbolClass from '@iconify-icons/codicon/symbol-class';
import vsiSymbolMethod from '@iconify-icons/codicon/symbol-method';
import { FileCodeIcon, LinkExternalIcon } from '@primer/octicons-react';
import { SourceURL, Splitter } from '@site/src/envs/variables';

<p>
  <InlineIcon icon={vsiSymbolClass} width='1.35rem' style={{"verticalAlign": "bottom"}} /> Class
  <Splitter />
  <SourceURL url="mproc.py#L37">
    <FileCodeIcon size={18} verticalAlign="middle" /> Source
  </SourceURL>
</p>

```python
tbuf = syncstream.mproc.LineBuffer(maxlen=20)
tbuf = syncstream.LineBuffer(...)  # Alias
```

The basic line-based buffer handle.

This buffer provides a rotating item stroage for the text-based stream. The text is stored not by length, but by lines. The maximal line number of the storage is limited.

## Arguments

### Requires

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `maxlen`   | `int`  | The maximal number of stored lines. This value has the same meaning of [<LinkExternalIcon size={18} verticalAlign="middle" />`deque.maxlen`](https://docs.python.org/3/library/collections.html#collections.deque.maxlen). |

## Methods

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `clear`

```python
tbuf.clear()
```

Clear the whole buffer.

This method would clear the storage and the last line stream of this buffer. However, it would not clear any mirrors or copies of this object. This method is thread-safe and should always success.

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `new_line`

```python
tbuf.new_line()
```

Clear the current temporary buffer, and manually trigger a new line signal. If the current temporary buffer contains data, the data would be moved to the storage, and a new line would be created. If the current temporary buffer is already a new line, do nothing.

This method is equivalent to

```python
if tbuf.last_line.tell() > 0:
    write('\n')
```

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `flush`

```python
tbuf.flush()
```

Flush the current written line stream (temporary buffer).

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `parse_lines`

```python
tbuf.parse_lines(lines)
```

Parse the lines.

This method would be triggered when the new lines are written by `write()` method. The default behavior is adding the item into the storage.

Users could inherit this method and override it with their customized parsing method, like regular expression searching. The default behavior is implemented by:

```python
tbuf.storage.extend(lines)
```

#### Requires

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `lines`    | `[str]`  | A sequence of strs to be written in the storage. Users could catch any line item, and extract any specific information from it. |

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `read`

```python
lines = tbuf.read(size=None)
```

Fetch the stored record items from the buffer. Using the `read()` method is thread-safe and would not influence the cursor of `write()` method.

If the current written line is not blank, the `read()` method would regard it as the last record item.

#### Requires

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `size`     | `int`  | If set None, would return the whole storage. If set a int value, would return the latest `size` items. |

#### Returns

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `lines`    | `[str]`  | The returned messages. The messages have been already split by the line breaks. |

### <InlineIcon icon={vsiSymbolMethod} width='1.35rem' style={{"verticalAlign": "bottom"}} /> `write`

```python
n_bytes = tbuf.write(data)
```

The writting method of the buffer. The source `data` is the same as that of a text-based IO. Each time when `data` contains a line break, a new record item would be pushed in the storage. The `write()` method is thread-safe.

#### Requires

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `data`     | `str`  | The written messages. The line breaks would be detected automatically. |

#### Returns

|  Argument  |  Type  |  <center>Description</center>  |
| :--------: | :----: | :----------------------------- |
| `n_bytes`  | `int`  | The number of bytes that would be written to the buffer. This value is counted from the input `data` directly. |

## Example

<Tabs
  defaultValue="codes"
  values={[
    { label: 'Codes', value: 'codes', },
    { label: 'Results', value: 'results', },
  ]
}>

<TabItem value="codes">

```python
import contextlib
from syncstream.mproc import LineBuffer

tbuf = LineBuffer(5)

with contextlib.redirect_stdout(tbuf):
    for i in range(10):
        print(i)

print(tbuf.read())
```

</TabItem>

<TabItem value="results">

```shell
('5', '6', '7', '8', '9')
```

</TabItem>
</Tabs>
